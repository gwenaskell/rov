from typing import Final, TYPE_CHECKING, NewType
import math


if TYPE_CHECKING:

    class Deg(float):
        def __abs__(self) -> "Deg": ...
        def __mul__(self, d: float) -> "Deg": ...
        def __rmul__(self, d: float) -> "Deg": ...
        def __truediv__(self, v: float, /) -> "Deg": ...
        def __add__(self, value: "Deg", /) -> "Deg": ...
        def __sub__(self, value: "Deg", /) -> "Deg": ...
        def __radd__(self, value: "Deg", /) -> "Deg": ...
        def __rsub__(self, value: "Deg", /) -> "Deg": ...
        def __eq__(self, value: "Deg", /) -> bool: ...
        def __ne__(self, value: "Deg", /) -> bool: ...
        def __lt__(self, value: "Deg", /) -> bool: ...
        def __le__(self, value: "Deg", /) -> bool: ...
        def __gt__(self, value: "Deg", /) -> bool: ...
        def __ge__(self, value: "Deg", /) -> bool: ...

else:
    Deg = NewType("Deg", float)

__deg_to_rad__ = Deg(math.pi / 180)


if TYPE_CHECKING:

    class Rad(float):
        def __abs__(self) -> "Rad": ...
        def __mul__(self, d: float) -> "Rad": ...
        def __rmul__(self, d: float) -> "Rad": ...
        def __truediv__(self, v: float, /) -> "Rad": ...
        def __add__(self, value: "Rad", /) -> "Rad": ...
        def __sub__(self, value: "Rad", /) -> "Rad": ...
        def __radd__(self, value: "Rad", /) -> "Rad": ...
        def __rsub__(self, value: "Rad", /) -> "Rad": ...
        def __eq__(self, value: "Rad", /) -> bool: ...
        def __ne__(self, value: "Rad", /) -> bool: ...
        def __lt__(self, value: "Rad", /) -> bool: ...
        def __le__(self, value: "Rad", /) -> bool: ...
        def __gt__(self, value: "Rad", /) -> bool: ...
        def __ge__(self, value: "Rad", /) -> bool: ...

else:
    Rad = NewType("Rad", float)

__rad_to_deg__ = Rad(180 / math.pi)

pi: Final[Rad] = Rad(math.pi)


def deg(r: Rad) -> Deg:
    return Deg(r * __rad_to_deg__)


def rad(r: Deg) -> Rad:
    return Rad(r * __deg_to_rad__)


def atan2(y: float, x: float) -> Rad:
    return Rad(math.atan2(y, x))


def asin(x: float) -> Rad:
    return Rad(math.asin(x))


def safe_asin(value: float) -> Rad:
    if value <= -1.0:
        return Rad(pi / -2.0)

    if value >= 1.0:
        return Rad(pi / 2.0)

    return Rad(asin(value))
